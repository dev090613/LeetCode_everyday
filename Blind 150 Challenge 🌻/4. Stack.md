1. Valid Parentheses(20)

~~~python
# í•­ìƒ ê³ ë¯¼í•  ê²ƒ: ì–´ë–¤ ideaë¡œ ì ‘ê·¼í•  ê²ƒì¸ê°€. ê·¸ë¦¬ê³  ê·¸ ideaë¥¼ ì±„íƒí•œ ì´ìœ ëŠ” ë¬´ì—‡ì¸ê°€
# ì¢‹ì€ ìŠµê´€: test case ì‘ì„± -> visualization / complexityë¥¼ ìƒê°í•´ë³¸ë‹¤.
# ë¬¸ì œ: ê´„í˜¸ê°€ ê°™ì€ typeì˜ ê´„í˜¸ë¡œ ë‹«í˜, ì˜¬ë°”ë¥¸ ìˆœì„œë¡œ ë‹«í˜, 
# idea: ìˆœì„œê°€ ìˆëŠ” ë¬¸ì œ.. First iní•œ ê´„í˜¸ê°€ Last out í•œë‹¤. ì—¬ë‹«ëŠ” ê´„í˜¸ë“¤ì´ match í•˜ë¯€ë¡œ hash map ì‚¬ìš©í•œë‹¤. ë‹«ëŠ” ê´„í˜¸ë¥¼ ë°œê²¬í•˜ë©´ ì—¬ëŠ” ê´„í˜¸ë¥¼ ì‚­ì œí•´ì¤€ë‹¤.
# Time O(n) Space O(n)

class Solution:
    def isValid(self, s: str) -> bool:
        '''
        s: "( [ ) ] "
        c:      ^
        stack = [ '(' '['  ] # ë‹«íˆëŠ” ê´„í˜¸ê°€ stack[-1]ì¼ ë•Œ ì œê±°ë˜ë„ë¡ í•œë‹¤
        closeToOpen = {')':'(', ']':'[', '}':'{'} # hashmap
        '''
        stack = [] # pythonì—ì„œëŠ” listë¥¼ stackìœ¼ë¡œ ì‚¬ìš©
        closeToOpen = {')':'(', ']':'[', '}':'{'} # It is a Hashmap
        
        #input stringì—ì„œ í•˜ë‚˜ì”© ì œê±°í•  ê²ƒ
        for c in s:
            # cê°€ ë‹«íŒ ê´„í˜¸ë¼ë©´?
            if c in closeToOpen: # keyë¥¼ ê¸°ì¤€ìœ¼ë¡œ íƒìƒ‰í•œë‹¤.
                # stackì´ not emptyì´ë©° ê°€ì¥ ìµœê·¼ì— ì‚½ì…ëœ ê²ƒì´ í˜„ì¬ ë‹«íŒ ê´„í˜¸ì™€ ì§ì´ë¼ë©´ ì œê±°
                if stack and stack[-1] == closeToOpen[c]:
                    stack.pop()
                else:
                    # print(f"stack is {stack}") # Debug
                    return False
            # cê°€ ë‹«íŒ ê´„í˜¸ê°€ ì•„ë‹ˆë¼ë©´
            else:
                stack.append(c)
        # print(f"stack is {stack}") # Debug
        # stackì´ ë¹„ì–´ìˆìœ¼ë©´ True ë°˜í™˜ ì•„ë‹ˆë©´ False ë°˜í™˜
        return True if not stack else False
~~~

2. ##### Min Stack(155)

<img src="/Users/isntsoo/Library/Application Support/typora-user-images/image-20230528125652143.png" alt="image-20230528125652143" style="zoom:50%;" />

~~~python
# Q: Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
# You must implement a solution with O(1) time complexity for each function.
# Methods pop, top and getMin operations will always be called on non-empty stacks.
# Follow up: Time O(1)
class MinStack:

    # ì¼ë°˜ stackê³¼ getMin()ì„ êµ¬í˜„í•˜ê¸° ìœ„í•œ Stackì„ í•˜ë‚˜ ë” ë§ˆë ¨ ğŸ¥¸
    def __init__(self):
        self.stack = []
        self.minStack = [] 

    # pushes the element val onto the stack.
    def push(self, val: int) -> None:
        self.stack.append(val)
        val = min(val, self.minStack[-1] if self.minStack else val) # ğŸ¤­
        self.minStack.append(val)

    # removes the element on the top of the stack.
    def pop(self) -> None:
        self.stack.pop()
        self.minStack.pop()
        
    # gets the top element of the stack
    def top(self) -> int:
        return self.stack[-1]

    # retrieves the minimum element in the stack.
    def getMin(self) -> int:
        return self.minStack[-1]
        
# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
~~~

