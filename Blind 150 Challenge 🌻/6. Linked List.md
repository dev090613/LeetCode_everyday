1. Reverse Linked List(206)

- ë¬¸ì œ: linked listë¥¼ ì—­ìˆœìœ¼ë¡œ ë’¤ì§‘ì–´ë¼
- Idea: pointerë¥¼ ê·¸ëƒ¥ ë’¤ì§‘ìœ¼ë©´ ë‹¤ìŒ ì£¼ì†Œë¥¼ ìƒì–´ë²„ë¦°ë‹¤. tempê°€ í•„ìš”í•˜ë‹¤.
- Learned:
- follow up - iterative ì™€ recursion ë‘ ê°€ì§€ ë°©ë²•ìœ¼ë¡œ í’€ì–´ë³´ê¸°

~~~python
# Two pointer solution

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """
              [<-1<-2  3->4->5] 
        curr           ^
        prev        ^
        temp           ^
        
        Time O(n) Memory O(1)
        """
        prev, curr = None, head
        
        while curr:
          	temp = curr.next # ì´ ë¶€ë¶„ì´ í•µì‹¬
          	curr.next = prev
            prev = curr
            curr = temp
        return prev        
~~~

~~~python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """
        None head -> head.next -> ... -> None
        ì„ì˜ì˜ ìœ„ì¹˜(curr)ì—ì„œ ì‹œì‘
        3 pointer: prev, curr, next_node
        """
        def reverse(curr, prev):
            # Empty list
            if not curr: 
                return prev
            
            next_node = curr.next
            curr.next = prev
            return reverse(next_node, curr)
                
        return reverse(head, None)
~~~

~~~python
# ì´í•´í•˜ê¸° ì–´ë ¤ìš´ ì½”ë“œ, ì¼ë‹¨ ê±´ë„ˆë›´ë‹¤.
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """
        1 -> 2 -> 3 -> 4 -> 5 -> None
        5 -> 4 -> 3 -> 2 -> 1 -> None
        Time: O(n) Space: O(n)
        """
        if not head:
            return None
        
        newHead = head # 1
        if head.next:
          	# 2~5ê¹Œì§€ reversedList ë°˜í™˜, newHead = 5
            newHead = self.reverseList(head.next)
            # 1 -> 2 <- 3 <- 4 <- 5)
            head.next.next = head
        head.next = None
        return newHead
~~~

2. Merge Two Sorted Lists(21)

- ë¬¸ì œ:
- Idea: 
- Learned:

~~~python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        """
        list1: [1,2,4]
                ^
                
        list2: [1,3,4,5,6]
                ^
        Return the head of the merged linked list.
        """
                
        dummy = ListNode() # ListNode{val: 0, next: None}
        tail = dummy
 
        # print(list1) # ListNode{val: 1, next: ListNode{val: 2, next: ListNode{val: 4, next: None}}}
        while list1 and list2:
            if list1.val < list2.val:
                tail.next = list1
                list1 = list1.next
            else:
                tail.next = list2
                list2 = list2.next
            tail = tail.next
        if list1:
            tail.next = list1
        elif list2:
            tail.next = list2
        return dummy.next # Dummy start at None
~~~

3. Reorder List(143)

- ë¬¸ì œ:
- Idea: 
- Learned:

~~~python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        # memory O(1)ìœ¼ë¡œ í’€ì–´ë³´ì
        # idea: 1) linked listë¥¼ ë‘ ë¶€ë¶„ìœ¼ë¡œ êµ¬ë¶„í•œë‹¤.(slow, fast pointer) 
        # 2) second half(ë°˜ìœ¼ë¡œ ë‚˜ëˆˆ ê²ƒì˜ ë‘ ë²ˆì§¸) ë¶€ë¶„ì„ reverseí•œë‹¤. (temp)
        # 3) êµì°¨í•˜ë©° merge í•œë‹¤. (temp)
        
        # 1)
        slow, fast = head, head.next # fastë¥¼ headê°€ ì•„ë‹Œ head.nextë¡œ ë‘ì–´ì„œ ìµœì¢…ì ìœ¼ë¡œ slow pointerì˜ ìœ„ì¹˜ê°€, ë…¸ë“œê°€ ì§ìˆ˜ì¸ ê²½ìš°ì™€ í™€ìˆ˜ì¸ ê²½ìš° ì–´ë–»ê²Œ ë‹¤ë¥¸ê°€ ìƒê°í•˜ê¸°
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        # print(f"slow is {slow}")
        # print(f"fast is {fast}")
        second = slow.next # second half
        slow.next = None # first halfì˜ ë§ˆì§€ë§‰ node

        # 2)
        prev = None
        while second:
            temp = second.next
            second.next = prev
            prev = second
            second = temp
        # print(f"prev is {prev}")

        # 3)
        # two pointer ì„¤ì •.
        # í˜„ì¬ prevê°€ second partì˜ new head
        first, second = head, prev 
        # print(first, second)
        while first and second: # secondê°€ í™€ìˆ˜ì¸ ê²½ìš° ë” ì§§ìŒ, ì§ìˆ˜ì¸ ê²½ìš° ë™
            temp1, temp2 = first.next, second.next
            first.next = second
            second.next = temp1
            first, second = temp1, temp2 # pointer ì´ë™

~~~

4. Linked List Cycle(141)

- ë¬¸ì œ:
- Idea: 
- Learned:

~~~python
# Floyd's Tortoise & Hare algorithm

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        """
        Idea: cycleì´ë¼ë©´ ë¹ ë¥¸ ì£¼ìì™€ ëŠë¦° ì£¼ìëŠ” ê²°êµ­ ë§Œë‚˜ê²Œ ëœë‹¤.
        Time O(n): 1íšŒ ì‹œí–‰ ì‹œ fast - slow = 1 ì´ë¯€ë¡œ nê°œì˜ nodeë¼ë©´ ìµœëŒ€ në²ˆ
        """        
        slow, fast = head, head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if fast == slow:
                return True
        
        return False
~~~

5. ##### Remove Nth Node From End of List(19)

- linked listì™€ nì´ ì¸í’‹ìœ¼ë¡œ ì£¼ì–´ì¡Œì„ ë•Œ
  nì€ offsetì´ë‹¤.
   1) ì˜ˆì™¸ì²˜ë¦¬ë¥¼ ìœ„í•´ dummy nodeë¥¼ í™œìš©
   2) l, r pointer ë‘ê³ , ê·¸ ê°„ê²©ì„ ë§Œë“ ë‹¤
  	(ë°˜ë³µë¬¸ìœ¼ë¡œ offset ì„¤ì •)
   3) l pointerê°€ ì œê±°í•  ë…¸ë“œì˜ ì§ì „ nodeë¡œ ë‘” ë’¤ next.next nodeì™€ ì—°ê²°

~~~python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        """[1, 2, 3, 4, 5], n = 2        
         dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL
        l                   ^
        r                                     ^
        dummy -> 1 -> 2 -> 3 -> 5 -> NULL
        """
        # dummy nodeë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ ? ì˜ˆì™¸ì²˜ë¦¬ë¥¼ ì‰½ê²Œ í•˜ê¸° ìœ„í•´.
        # ì˜ˆë¥¼ ë“¤ë©´ ì´ ë¬¸ì œì˜ inputì´ [1], n=1ì¸ ê²½ìš° 
        dummy = ListNode(0, head) # ğŸ§
        # print(dummy) # ListNode{val: 0, next: None}

        # offsetì„ ì„¤ì •í•˜ê¸° ìœ„í•œ ë°˜ë³µë¬¸
        l, r = dummy, head
        for i in range(n): # ğŸ˜³
            r = r.next

        # l pointerë¥¼ ë°°ì œí•  ë…¸ë“œì˜ ì§ì „ nodeë¡œ ë§Œë“ ë‹¤.
        while r:
            r = r.next
            l = l.next
        
        # ë°°ì œ
        l.next = l.next.next

        # headê°€ ì•„ë‹ˆë¼ dummy.nextë¥¼ returní•´ì•¼ ì˜ˆì™¸ì²˜ë¦¬ê°€ ëœë‹¤.
        return dummy.next 
~~~
