---
2023ë…„ 5ì›” 8ì¼ ì‹œì‘, 6ì›” 10ì¼ê¹Œì§€ ë‚´ê°€ ì›í•˜ëŠ” 40ë¬¸ì œ í’€ê¸°
---

##### 1. Two sum 2(167) ğŸª´

- ë¬¸ì œ: ì˜¤ë¦„ì°¨ìˆœì¸ listê°€ ìˆë‹¤. ë‘ itemì˜ í•©ì´ targetê³¼ ê°™ë‹¤ë©´, ê·¸ ì¸ë±ìŠ¤+1ì„ ë°˜í™˜

- idea: sortedëœ ìƒíƒœì´ë¯€ë¡œ ì–‘ ëì˜ Two pointerì˜ ê°’ì„ Targetê³¼ ë¹„êµí•˜ë©° í•œ ì¹¸ì”© ì´ë™í•˜ì—¬ í’€ ìˆ˜ ìˆë‹¤.
- ë°°ìš¸ ê²ƒ: Two sum1ê³¼ì˜ ì°¨ì´ëŠ” sorted ë˜ì—ˆëŠ”ì§€ ì—¬ë¶€ì´ë‹¤. two sum1ì€ hashmap(value:index)ìœ¼ë¡œ í’€ì—ˆë‹¤. sorted ëœ ê²½ìš° two pointer vs targetìœ¼ë¡œ ì ‘ê·¼í•˜ì.
- ë‹¤ë¥¸ í’€ì´: Hashmap, Brute force

~~~python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        """
        ì „ì œ: ì˜¤ë¦„ì°¨ìˆœ
           [2,7,11,15], 9
        l:  ^
        r:      ^
        cusSum = 2 + 11 = 9 > target => r-1
        Time: O(n), Space: O(1)
        """
        l, r = 0, len(numbers)-1
        
        while l<r:
            cur_sum = numbers[l] + numbers[r]
            
            if cur_sum > target:
                r -= 1
            elif cur_sum < target:
                l += 1
            else:
                return [l + 1, r + 1]
        return
~~~

##### 2. Remove Duplicates from Sorted Array(26)

- ë¬¸ì œ: ì˜¤ë¦„ì°¨ìˆœ, unique valueì˜ itemë§Œìœ¼ë¡œ ë‹¹ê²¨ì„œ ì±„ì›Œë„£ì–´ë¼. ê·¸ í›„ì˜ ê°’ë“¤ì€ ê³ ë ¤í•˜ì§€ ì•ŠëŠ”ë‹¤. ê°œìˆ˜ë¥¼ ë°˜í™˜í•˜ë¼
- idea: Two pointer
- Follow up: Space complexity O(1)

~~~python
# input [0, 1, 2, 2, 3, 3, 4]
# output 5 ì™œëƒí•˜ë©´, [0, 1, 2, 3, 4]
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        """
          [0, 1, 2, 2, 3, 3, 4] => ì´ë ‡ê²Œ [0, 1, 2, 3, 4]
        l     ^
        r     ^
        """
        l = 1 # index 0 ìœ„ì¹˜ëŠ” ê³ ë ¤í•˜ì§€ ì•ŠìŒ
        
        for r in range(1, len(nums)):
            if nums[r] != nums[r-1]: # ì´ ë¶€ë¶„ì´ í•µì‹¬ â˜˜ï¸
                nums[l] = nums[r]
                l += 1
        return l
~~~

##### 3. Maximum Difference Between Increasing Elements(2016)

~~~python
# ì£¼ì‹ìœ¼ë¡œ ìˆ˜ìµë‚´ê¸°ì™€ ë§¤ìš° ë¹„ìŠ·í•œ ë¬¸ì œ ê°™ë‹¤.
# ë‘ ìš”ì†Œì˜ ì°¨ê°€ ì¦ê°€ë¶„ì´ ì•„ë‹ˆë¼ë©´ -1ì„ ë°˜í™˜í•˜ë¼
# idea: Slid window
# ë°°ìš¸ ê²ƒ: ê³ ì • ê°’(ì‘ì€ ê°’)ë³´ë‹¤ ì‘ì€ ê°’ì´ ë‚˜ì˜¤ë©´ ê·¸ ìœ„ì¹˜ìœ¼ë¡œ ì´ë™í•œë‹¤.
# [3,5,2,10] => 8
# [9,4,3,2] => -1
class Solution:
    def maximumDifference(self, nums: List[int]) -> int:
        l = 0
         
        res = 0
        for r in range(1, len(nums)):
            if nums[l] > nums[r]:
                l = r
            res = max(res, nums[r] - nums[l])
        return res if res != 0 else -1    
~~~

##### 4. Find First Palindromic String in the Array(2018)

~~~python
# idea: Two pointer
# ë°°ìš¸ ê²ƒ: ì—¬ëŸ¬ í•¨ìˆ˜ë¡œ ìª¼ê°œê¸°
# Time: O(n)
# ë‹¤ë¥¸ í’€ì´: slicing
class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for word in words:
            if self.isPalindrome(word):
                return word
        return ""
    
    def isPalindrome(self, word):
        l, r = 0, len(word)-1
        while l<r:
            if word[l] != word[r]:
                return False
            l += 1
            r -= 1
        return True
~~~

~~~python
class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for word in words:
            if word == word[::-1]:
                return word
        return ""
~~~

##### 5. Valid Palindrome II(680)

~~~python
# ë¬¸ì œ: Palindromeì¸ì§€ íŒë‹¨, í•˜ë‚˜ì˜ charê¹Œì§€ëŠ” ì§€ìš¸ ìˆ˜ ìˆë‹¤.
# idea: ë¶ˆì¼ì¹˜ì˜ ê²½ìš° ê±´ë„ˆë›´ í›„ ë‹¤ì‹œ í•¨ìˆ˜ë¥¼ í•œ ë²ˆ ë¶ˆëŸ¬ì˜¨ë‹¤. Returnìœ¼ë¡œ ë°”ë¡œ ëë‚´ê¸° ë•Œë¬¸ì— ëª‡ ë²ˆ ì‚­ì œí•  ìˆ˜ ìˆëŠ”ì§€ì— ê´€í•´ì„  ê³ ë ¤í•˜ì§€ ì•Šì•˜ìŒ flagë¥¼ ì‚¬ìš©í•˜ë©´ ì‚­ì œ íšŸìˆ˜ë„ ì¡°ì ˆí•  ìˆ˜ ìˆì„ ê²ƒ ê°™ìŒ
# ë°°ìš¸ ê²ƒ: return A or Bì˜ ì‚¬ìš©(logical operator), í•¨ìˆ˜ì˜ ì‚¬ìš©ë²•(argument ì´ˆê¸°í™” ì¡°ì‹¬í•˜ê¸°)
# ë‹¤ë¥¸ í’€ì´: Flagë¥¼ ì‚¬ìš©í•´ë„ ë  ê²ƒ ê°™ì€ë°..., Slicingìœ¼ë¡œ ì½”ë“œë¥¼ ì‘ì„±í•´ë„ ì¢‹ê² ë‹¤.
class Solution:
    def validPalindrome(self, s: str) -> bool:
        l, r = 0, len(s)-1
        while(l < r):
            if s[l] != s[r]:
                return self.isPalindrome(s, l+1, r) or self.isPalindrome(s, l, r-1)
            l+=1
            r-=1
        return True
    
    def isPalindrome(self, s, l, r):
        # l, r = 0, len(s)-1 # ì˜¤ë‹µì˜ ì›ì¸. í•¨ìˆ˜ë¥¼ ë¶ˆëŸ¬ì˜¤ê³ ë‚˜ì„œ ë‹¤ì‹œ ì´ˆê¸°í™” ì‹œì¼°ìŒ...
        while l < r:
            if s[l] != s[r]:
                return False
            l+=1
            r-=1
        return True
~~~

##### 6. Middle of the Linked List(876)

~~~python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast, slow = head, head
        
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        
        return slow
~~~

##### 7. Implement Stack using Queues(225)

<img src="/Users/isntsoo/Library/Application Support/typora-user-images/image-20230529160434847.png" alt="image-20230529160434847" style="zoom:50%;" />

~~~python
# Implement Stack Using Queues(225): Implement a last-in-first-out (LIFO) stack using only two queues.
class MyStack:
    """
    queue(FIFO)ë¡œ stack(LIFO)ë¥¼ êµ¬í˜„í•´ì•¼ í•œë‹¤.
    """
    def __init__(self):
        """
        Initialize my data structure here
        """
        self.q = deque()

    def push(self, x: int) -> None:
        """
        Pushes element x to the top of the stack.
        Time: O(1), Space: O(1)
        """
        self.q.append(x) # queue, stack ë™ì¼
        
    def pop(self) -> int:
        """
        Removes the element on the top of the stack and returns it.
        Time: O(n), stackê³¼ ë‹¬ë¦¬ O(1)ì´ ì•„ë‹ˆì§€ë§Œ ì´ê²Œ ìµœì„ ì´ë‹¤.
        """
        # ì–´ë ¤ìš´ ë¶€ë¶„
        for i in range(len(self.q) - 1):
            self.push(self.q.popleft())
        return self.q.popleft()
        
    def top(self) -> int:
        """
        Returns the element on the top of the stack.
        """
        return self.q[-1] # stack[-1] ê°€ëŠ¥í•˜ë¯€ë¡œ
        
    def empty(self) -> bool:
        """
        Returns true if the stack is empty, false otherwise.
        """
        return len(self.q) == 0

# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()
~~~

~~~asciiarmor
Solve Implement Stack using Queues(225)

Queueì˜ ê¸°ëŠ¥ë§Œìœ¼ë¡œ Stackì˜ ê¸°ëŠ¥ì„ êµ¬í˜„í•´ì•¼ í•˜ëŠ” ë¬¸ì œì˜€ë‹¤.

itemì´ ìë£Œêµ¬ì¡° ì†ìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” í˜•íƒœëŠ” ë‘˜ì´ ê°™ì§€ë§Œ, 
Out(self.pop())í•  ë•Œ Stackê³¼ Queueì˜ ì‘ë™ ë°©ì‹ì´ ë‹¤ë¥¸ë°, 
ì´ ë¶€ë¶„ì—ì„œ Time complexityë¥¼ O(n)ë³´ë‹¤ ì¢‹ì„ ìˆ˜ëŠ” ì—†ë‹¤.
rotationí•˜ì—¬ topì— ìœ„ì¹˜í–ˆë˜ ê°’ì´ queueì˜ ì²«ë¶€ë¶„ìœ¼ë¡œ ì˜¤ê²Œ ë§Œë“  í›„
ì´ë¥¼ ë°˜í™˜í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í–ˆë‹¤.

ì¶”ìƒí™”ì´ë¯€ë¡œ êµ¬ì²´ì ì¸ ì‘ë™ ë°©ì‹ì€ ë‹¤ë¥´ì§€ë§Œ ì‹¤í–‰ ëì„ ë•Œ ê°’ì€ ê°™ì•„ì„œ ê´œì°®ë‹¤ê³  ìƒê°í•œë‹¤.
topì˜ ê²½ìš° stackë„ [-1]ìœ¼ë¡œ ì ‘ê·¼í•˜ë¯€ë¡œ ë™ì¼í•˜ê²Œ í•´ê²°í–ˆë‹¤.
ë¬¸ì œ ìì²´ë¥¼ ì´í•´í•˜ëŠ” ê²ƒì´ ì–´ë ¤ì› ë‹¤.

íŠ¹íˆ ì²˜ìŒ __init__(self) methodì—ì„œ ìë£Œêµ¬ì¡°ë¥¼ ì„ ì–¸í•˜ëŠ” ê²ƒì¡°ì°¨ í‹€ë ¸ì—ˆë‹¤.
ì´ ë¬¸ì œë¥¼ í†µí•´ pythonì—ì„œ dequeueë¥¼ ì‚¬ìš©í•˜ëŠ” ë²•ì„ ë°°ì› ë‹¤.
~~~

##### 8. design hashset

- Collision handleì´ ì¤‘ìš”
- hashset can not contain duplicate

<img src="/Users/isntsoo/Library/Application Support/typora-user-images/image-20230530230019192.png" alt="image-20230530230019192" style="zoom:25%;" />

~~~python
# key, valueë¥¼ ì €ì¥í•  LLì„ ë§Œë“¤ì–´ì¤€ë‹¤.
class ListNode:
    def __init__(self, key):
        self.key = key
        self.next = None

class MyHashSet:
    """
    Design a HashSet without using any built-in hash table libraries.
    At most 10^4 calls will be made to add, remove, and contains
    linked listë¥¼ ì‚¬ìš©í•  ê²ƒì´ë‹¤.
    """
    def __init__(self):
        self.set = [ListNode(0) for i in range(10 ** 4)] # dummy nodeë¡œ ì´ë£¨ì–´ì§„ container, ì¶©ëŒì„ í”¼í•˜ê¸° ìœ„í•´ ìµœëŒ€í•œ í¬ê²Œ ë§Œë“¬
        
    # Inserts the value key into the HashSet.
    def add(self, key: int) -> None:
        index = key % len(self.set) # keyê°€ ë“¤ì–´ê°ˆ indexë¥¼ ì •í•œë‹¤.
        curr = self.set[index] # í•´ë‹¹ indxì˜ dummy nodeë¥¼ ê°€ë¦¬í‚´
        # ë™ì¼í•œ keyê°€ ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•œë‹¤.
        while curr.next: # dummy nodeì˜ ë‹¤ìŒ nodeë¶€í„° í™•ì¸í•˜ë©´ ëœë‹¤.
            if curr.next.key == key:
                return
            curr = curr.next # ë‹¤ìŒ ë…¸ë“œë„ ì‚´í´ë³´ê¸° ìœ„í•´
        curr.next = ListNode(key)
        
    # Removes the key in the HashSet(If key does not exist do nothing.)
    def remove(self, key: int) -> None:
        index = key % len(self.set)
        curr = self.set[index]
        while curr.next:
            if curr.next.key == key:
                curr.next = curr.next.next
                return
            curr = curr.next
        
    # Returns whether the value key exists in the HashSet or not.
    def contains(self, key: int) -> bool:
        index = key % len(self.set)
        curr = self.set[index]
        while curr.next:
            if curr.next.key == key:
                return True
            curr = curr.next
        return False


# Your MyHashSet object will be instantiated and called as such:
# obj = MyHashSet()
# obj.add(key)
# obj.remove(key)
# param_3 = obj.contains(key)
~~~

~~~asciiarmor
Solve Design Hash Set

ê°„ë‹¨í•œ hash setì„ êµ¬í˜„í•˜ëŠ” ë¬¸ì œì´ë‹¤.
ì •ì„ì ì¸ hash setì€ collisionì„ ìµœì†Œë¡œ ë§Œë“¤ê¸° ìœ„í•´ì„œ ì‚¬ì´ì¦ˆê°€ êµ‰ì¥íˆ ì‘ê³ 
ë³µì¡í•œ hash functionì„ ì‚¬ìš©í•˜ì§€ë§Œ ì´ ë¬¸ì œëŠ” ê·¸ëŸ¬í•œ ë²”ìœ„ê¹Œì§€ëŠ” ë‹¤ë£¨ì§€ ì•ŠëŠ”ë‹¤.
ìµœëŒ€ 10 ** 4 ë²”ìœ„ì˜ ê°œìˆ˜ê¹Œì§€ë§Œ ë‹´ì„ ìˆ˜ ìˆë‹¤ê³  ì„¤ì •í•œ í›„ì— ê·¸ í¬ê¸°ë¥¼ ëª¨ë“ˆëŸ¬ë¡œ ë‚˜ëˆ„ëŠ” ë°©ì‹ì„ ì±„íƒí–ˆë‹¤.

ì°¸ê³ ë¡œ ì¶©ëŒì´ ì¦ë‹¤ë©´, ì¦‰ í•˜ë‚˜ì˜ ë°”êµ¬ë‹ˆì— ì—¬ëŸ¬ ê°€ì§€ì˜ ê°’ì´ ë“¤ì–´ê°€ë©´, ì´ê²ƒì€ linked listì²˜ëŸ¼ ì—°ê²°ë˜ì–´ì„œ
O(n)ì— ê°€ê¹Œì›Œì§„ë‹¤. ì´ë¥¼ í•´ê²°í•˜ëŠ” ì›ë˜ì˜ hash tableì€ í‰ê· ì ìœ¼ë¡œ O(1)ì˜ search, insert timeì„ ê°–ëŠ”ë‹¤.

keyë“¤ì„ ì €ì¥í•˜ê¸° ìœ„í•´ì„œ dummy ë…¸ë“œë¥¼ ì‚¬ìš©í•˜ì˜€ë‹¤. ì›ë˜ì˜ hash mapì´ í•œ ì¸ë±ìŠ¤ì—ì„œ ê°’ë“¤ì„
linked listë¡œ ì €ì¥í•˜ë¯€ë¡œ ì´ê²ƒì€ ë§ëŠ” ë°©ì‹ì´ë‹¤.
whileë¬¸ì´ ì£¼ì˜í•  ì ì¸ë°, ë”ë¯¸ë…¸ë“œì—ì„œ ì‹œì‘í•˜ë¯€ë¡œ ê·¸ ì´í›„ ê°’ë“¤ì„ ì‚´í´ë³¸ë‹¤.

ì´ ë¶€ë¶„ë„ ì¤‘ìš”í•œë°, hashëŠ” duplicate valueë¥¼ ê°–ì§€ ì•Šìœ¼ë¯€ë¡œ whileë¬¸ì„ ëŒë©´ì„œ
ê°™ì€ ê°’ì„ ì°¾ì•„ê°€ë©° operationì„ êµ¬í˜„í•œë‹¤.

ê½¤ë‚˜ ê´œì°®ì€ ë¬¸ì œ ê°™ë‹¤.
~~~

##### 9. Merge strings alternately

~~~python
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        """
        Q: ê¸¸ì´ê°€ ë‹¤ë¥¸ ë‘ ë¬¸ìì—´ì„ ë²ˆê°ˆì•„ê°€ë©° merge
        Input: word1 = "abc", word2 = "pqr"
        Output: "apbqcr"
        point: If one string is longer than the other, the additional letters must be appended to the end of the merged string.
        idea
            1. Set two pointer, res(list) 
            2. Loop and merge using using len()
            3. Add remaining str using append()
            4. return using ""join(res)
        Time: O(m+n) = O(n)
        Space: O(1) - Without considering the space consumed by the input strings (word1 and word2) and the output string (result), we do not use more than constant space
        """
        i, j = 0, 0
        res = [] # strì´ ì•„ë‹Œ listë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ ? ì¼ë°˜ì ì¸ solutionì— ê°€ê¹ë„ë¡(ë‹¤ë¥¸ ì–¸ì–´ì™€ì˜ í˜¸í™˜).

        while i < len(word1) and j < len(word2):
            res += word1[i] + word2[j]
            i += 1
            j += 1

        res.append(word1[i:])
        res.append(word2[j:])

        return "".join(res)
        
~~~

~~~asciiarmor
Solve Merge strings alternately

ê¸¸ì´ê°€ ë‹¤ë¥¸ ë‘ ë¬¸ìì—´ì„ ë²ˆê°ˆì•„ê°€ë©° ì—°ê²°í•˜ëŠ” ë¬¸ì œì´ë‹¤.
strìœ¼ë¡œ í’€ì–´ë„ ë˜ê³ , listë¡œ í’€ì–´ë„ ë˜ëŠ”ë°
strìœ¼ë¡œ í‘¸ëŠ” ê²ƒì€ python specificì´ë¼ê³  ìƒê°ë˜ì–´ì„œ
listë¡œ í’€ì—ˆë‹¤. ì•„ì£¼ ê°„ë‹¨í•˜ì§€ë§Œ í•„ìˆ˜ì ì¸ ë‚´ìš©ì„ ë‹¤ë£¨ëŠ” ë¬¸ì œì´ë‹¤.
~~~

##### 10. Greatest Common Divisor of Strings(1071)

~~~python
class Solution:
    def is_divisor(self, str1, str2, sub_string):
        """
        sub_stringì´ str1ê³¼ str2ì˜ ìµœëŒ€ê³µì•½ìˆ˜ì¸ stringì¸ì§€ íŒë‹¨í•œë‹¤.
        return: 
        """
        # ë¬¸ìì—´ì˜ ê¸¸ì´ê°€ ìµœëŒ€ê³µì•½ìˆ˜ì¸ì§€
        if len(str1) % len(sub_string) or len(str2) % len(sub_string):
            return False
        f1, f2 = len(str1) // len(sub_string), len(str2) // len(sub_string)
        # ì‹¤ì œ ë¬¸ìì—´ì´ ìµœëŒ€ê³µì•½ìˆ˜ì¸ì§€
        return sub_string * f1 == str1 and sub_string * f2 == str2

    def gcdOfStrings(self, str1: str, str2: str) -> str:
        """ Greatest Common Divisor of Strings
        Q: we are looking for the Greatest Common Divisor of two strings
        
        Input: str1 = "ABABAB", str2 = "ABAB"
        Output: "AB"
        Input: str1 = "LEET", str2 = "CODE"
        Output: ""

        Idea
            ë‘ string ì¤‘ ì§§ì€ stringì„ ì •í•œë‹¤. str1
            ê·¸ stringì„ ê¸°ì¤€ìœ¼ë¡œ substringì„ ì°¾ëŠ”ë‹¤. greedy
                substringìœ¼ë¡œ ë‘ string ëª¨ë‘ ë‚˜ëˆ„ì–´ ë–¨ì–´ì ¸ì•¼ í•œë‹¤.
        """
        len1, len2 = len(str1), len(str2)

        for l in range(min(len1, len2), 0, -1): # % ì—°ì‚°ì„ í•  ê²ƒì´ë¯€ë¡œ
            if self.is_divisor(str1, str2, str1[:l]):
                return str1[:l]
        return ""

~~~

**11. Reverse string**	

<img src="/Users/isntsoo/Library/Application Support/typora-user-images/image-20230531214006224.png" alt="image-20230531214006224" style="zoom:25%;" />	

<img src="/Users/isntsoo/Library/Application Support/typora-user-images/image-20230531214625197.png" alt="image-20230531214625197" style="zoom: 25%;" />	

~~~python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Q: Write a function that reverses a string. The input string is given as an array of characters
        Follow-up - You must do this by modifying the input array in-place with O(1) extra memory
        í¬ì¸íŠ¸: 1) by modifying the input array, Space(1)
        Idea: 1) Two pointer, Swap
        """
        def sol1_two_pointer(): # Time(n) Space(1)

            l, r = 0, len(s)-1

            while l < r:
                s[l], s[r] = s[r], s[l]
                l += 1
                r -= 1
            return s
        
        sol1_two_pointer()

        def sol2_stack(): # Time(n) Space(n)
            stack = []

            for i in range(len(s)):
                stack.append(s[i])
            
            i = 0
            while stack:
                s[i] = stack.pop()
                i += 1
            
            return s

        # sol2_stack()
        
        def sol3_recursion(l, r):

            if l < r:
                s[l], s[r] = s[r], s[l]
                sol3_recursion(l+1, r-1)
            return

        # sol3_recursion(0, len(s)-1)
~~~



##### 12. Reverse Words in a String(151)

~~~python
~~~

