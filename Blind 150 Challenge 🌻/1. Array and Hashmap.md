##### 1. Contains Duplicate(217)

- ë¬¸ì œ: ì£¼ì–´ì§„ List[int]ì—ì„œ ë™ì¼í•œ ìˆ˜ê°€ ë‘ ë²ˆ ë°˜ë³µë˜ëŠ”ì§€
- idea: ë¹„ì–´ìžˆëŠ” hash setì— í•˜ë‚˜ ì”© ê°’ì„ ë„£ìœ¼ë©´ì„œ ì¤‘ë³µëœ ê°’ì´ ìžˆëŠ”ì§€ í™•ì¸í•œë‹¤.
- ë°°ìš¸ ê²ƒ: hashset = set(), hashset.add(n)
- ë‹¤ë¥¸ í’€ì´: Brute force, len(set(nums)), sort í›„ ì¸ì ‘í•œ ë‘ ê°œì˜ í¬ì¸í„° ì´ìš©

~~~python
# Contains Duplicate(217)
# hashset - ì•½ê°„ì˜ ë©”ëª¨ë¦¬ë¥¼ ë” ì‚¬ìš©í•˜ëŠ” ëŒ€ì‹  ì •ë ¬ ì—†ì´ constant time
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
      	"""
        Input: nums = [1,2,3,1]
        Output: true
        Time complexity: O(n). search() and insert() for n times and each operation takes constant time.
        Space complexity: O(n).
The space used by a hash table is linear with the number of elements in it.
      	"""
        prev_set = set() # ðŸ˜Ž
        for n in nums:
            if n in prev_set:
                return True
            prev_set.add(n) # ðŸ˜‡
        return False
~~~

~~~wiki
- Hash table: Utilize a dynamic data structure that supports fast search and insert operations.
- 
- For a Hash Table (HashSet or HashMap in Java), search() and insert() are both O(1) on average. cf> For a self-balancing Binary Search Tree (TreeSet or TreeMap in Java), search() and insert() are both O(logâ¡n) time.
- Therefore, by using hash table, we can achieve linear time complexity for finding the duplicate in an unsorted array.
~~~

~~~asciiarmor
Re-Solve Contains Duplicate
idea:
1. indexë¥¼ ëŒë©´ì„œ setì— ê° ì•„ì´í…œì„ insert.
2. ë™ì¼í•œ itemì´ ìžˆë‹¤ë©´ return True 
~~~

##### 2. Valid Anagram(242)

- idea: ë‘ ë¬¸ìžì—´ì´ Anagramì¸ ê²½ìš°, ëª¨ë“  characterì˜ ë°˜ë³µ íšŸìˆ˜ê°€ ë™ì¼í•˜ë‹¤.
- ë°°ìš¸ ê²ƒ: count = {}, ì—ëŸ¬ë¥¼ ë°˜í™˜í•˜ì§€ ì•Šê¸° ìœ„í•´ ê¸°ë³¸ê°’ ì‚¬ìš©
- ë‹¤ë¥¸ í’€ì´: Counter, sorted

~~~python
# Valid anagrad: ë‘ ë¬¸ìžì—´ì´ anagramì¸ì§€ íŒë‹¨í•˜ë¼
# Time: O(n), Space: O(n)
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        """
        s = "anagram", t = "nagaram" => True
        idea: Frequencu Counter
        """
        if len(s) != len(t):
            return False
        
        count_s, count_t = {}, {}
        
        for i in range(len(s)): # ðŸ˜‰
            count_s[s[i]] = count_s.get(s[i], 0) + 1
            count_t[t[i]] = count_t.get(t[i], 0) + 1
        for k in count_s:
        		# if count_s[k] != count_t[k]: ì˜ ë¬¸ì œì ? keyError ë°œìƒí•  ìˆ˜
        		# ì•„ëž˜ì˜ ì½”ë“œê°€ ê°œì„ ëœ ë°©ì‹. ì—ëŸ¬ë¥¼ ë°˜í™˜í•˜ì§€ ì•Šê³  ê¸°ë³¸ê°’ 0ì„ ë°˜í™˜í•˜ì—¬ ë¹„êµ
            if count_s[k] != count_t.get(k, 0): # ðŸ˜š
                return False
        return True
      	# ë‘ count ë¹„êµë¥¼ í•œ ì¤„ì—ë„ ëë‚¼ ìˆ˜ ìžˆë‹¤.
      	# return count_s == count_t
~~~

~~~wiki
- We could use a hash table to count the frequency of each letter, however, since both s and t only contain letters from a to z, a simple array of size 26 will suffice.
~~~

~~~python
# ë°©ë²•2: pythonic, Counter(): ë°©ë²• 2ì˜ ê¸°ëŠ¥ì´ íŒŒì´ì¬ì— built-inë˜ì–´ ìžˆë‹¤. ì†ë„ëŠ” ë” ë¹ ë¥´ë‹¤.
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)
        
        # return sorted(s) == sorted(t)        
~~~

~~~python
# Follow up: Space: O(1)ìœ¼ë¡œ í•´ê²°í•´ë³´ê¸°
# ë°©ë²•3: sorted, Time: O(nlogn) Space: O(1)
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return sorted(s) == sorted(t)
~~~

~~~asciiarmor
Re-Solve Valid anagram
idea:
1. ê¸¸ì´ê°€ ë‹¤ë¥´ë©´ anagramì´ ì•„ë‹ˆë‹¤
2. Frequency countë¥¼ ìœ„í•œ hash map ìƒì„±í•˜ê¸°
3. ë‘ count ë¹„êµí•˜ê¸°
~~~

##### 3. Two Sum(1)

- ë¬¸ì œì : list ë‚´ ë‘ ìˆ˜ì˜ ê°’ì˜ í•©ì´ target valueì¸ ê²½ìš° True ë°˜í™˜
- idea: ë¹ˆ hashmapì—ì„œ ì¶œë°œ(prev_map, 217ê³¼ ìœ ì‚¬), hashmap ë‚´ì— diff ê°’ì´ ìžˆëŠ”ì§€ í™•ì¸
- ë°°ìš¸ ì : enumerate í™œìš© ì‹œê¸°(listì˜ indexì™€ valueê°€ ëª¨ë‘ í•„ìš”í•œ ê²½ìš°), hashmap(value:index) ì‚¬ìš©

~~~python
# ì¤‘ìš”í•œ ë¬¸ì œ O(n), O(n)
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # ì°¾ì„ ê°’ì€ valueì´ê³  ë°˜í™˜í•  ê°’ì€ indexì´ë‹¤. ë”°ë¼ì„œ value:indexë¡œ ì„¤ì •
        prev_map = {}
        
        for i, n in enumerate(nums):
            diff = target - n
            if diff in prev_map:
                return [i, prev_map[diff]]
            prev_map[n] = i
        return # ë¬¸ì œì—ì„œ í•­ìƒ í•˜ë‚˜ì˜ ë‹µì´ ìžˆë‹¤ê³  í–ˆìœ¼ë¯€ë¡œ return ì—†ì–´ë„ ë¨
~~~

##### 4. Group Anagrams(49)

- ë¬¸ì œì :
- idea:
- ë°°ìš¸ ì : 

~~~python
# 49. Group Anagrams

# The functionality of both dictionaries and defaultdict are almost same except for the fact that defaultdict never raises a KeyError. It provides a default value for the key that does not exists.

# In python, list can't be key in dictionary. 
# list can be converted to tuple. 
# ë”°ë¼ì„œ, listëŠ” íŠœí”Œë¡œ ë³€í™˜ í›„ dictì˜ keyë¡œ ì‚¬ìš©í•  ìˆ˜ ìžˆë‹¤.
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        # KeyError ëŒ€ì‹  empty list ë°˜í™˜
        res = defaultdict(list)
        
        # ë™ì¼í•œ counterë¥¼ ê°€ì§„ strë“¤ë¼ë¦¬ ë¬¶ì„ ê²ƒì´ë‹¤.
        # { [counter1] : [str1, str2], 
        #   [counter2] : [str3] }
        for str in strs:
            counter = [0] * 26 # a-zì˜ ë°˜ë³µíšŸìˆ˜ ì €ìž¥ë  ê²ƒ
            for char in str:
                counter[ord(char) - ord('a')] += 1
            res[tuple(counter)].append(str) # counter ê°™ì€ strë¼ë¦¬ ëª¨ì¼ ê²ƒ
        return list(res.values())
~~~

~~~python
# í›¨ì”¬ ì¶•ì•½ëœ ì½”ë“œ, ì„±ëŠ¥ë„ ë” ë¹ ë¥´ë‹¤
# ìœ„ì˜ counter ë¥¼ sorted(str)ë¡œ í•´ê²°
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = defaultdict(list)
        for str in strs:
            res[tuple(sorted(str))].append(str) 
        return list(res.values())
~~~

##### 5. Longest Consecutive Sequence(128)

- ë¬¸ì œì :
- idea:
- ë°°ìš¸ ì : 

~~~python
# 128. Longest Consecutive Sequence
# input: [100,4,200,1,3,2] output: 4
# Idea: Consecutive Sequnceì˜ ì‹œìž‘ì ì€ -1ì˜ ê°’ì„ ê°€ì§€ê³  ìžˆì§€ ì•Šë‹¤.
# Time: O(n), Space: O(n)


class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        num_set = set(nums) # ì´ìœ : To allow O(1) lookups
        # ë°˜í™˜í•  ê°’ì¸ ê°€ìž¥ ê¸´ ê¸¸ì´
        longest = 0
        
        # numsì—ì„œ ê°€ìž¥ ê¸´ ë‹¨íŽ¸ì„ ì°¾ì„ ê²ƒì´ë‹¤.
        for num in nums: # O(n)
            # ë‹¨íŽ¸ì˜ ì‹œìž‘ì ì„ ì°¾ëŠ”ë‹¤.
            if (num - 1) not in num_set:
                length = 0 # 1ë¡œ ë‘ì–´ë„ ë¬´ë°©
                while (num + length) in num_set:
                    length += 1
                longest = max(length, longest) # scope ì£¼ì˜í•˜ê¸°
        return longest
~~~

##### 6. Top K Frequent Elements(347)

- ë¬¸ì œì :
- idea:
- ë°°ìš¸ ì : 

~~~python
# idea: frequencyë¥¼ indexë¡œ ì‚¼ëŠ” arrayë¥¼ ë§Œë“ ë‹¤. bucket sort
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = {}
        freq = [[] for i in range(len(nums) + 1)] # bucket ë§Œë“¤ê¸°. í•˜ë‚˜ì˜ ìˆ«ìžë§Œ ìžˆëŠ” ê²½ìš°, í•œ ê°œë„ ì—†ëŠ” ê²½ìš°ë„ ê³ ë ¤
        for num in nums:
            count[num] = count.get(num, 0) + 1
        # print(count)
        for n, c in count.items():
            freq[c].append(n)
        # print(freq)
        res = []
        for i in range(len(freq)-1, 0-1, -1):
            for n in freq[i]:
                res.append(n)
                if len(res) == k:
                    return res
        
        
# input: [1,1,1,2,2,3], 2
# count: {1: 3, 2: 2, 3: 1} O(n)
# index, value: [[None], [3], [2], [1], [None], [None], [None]] O(n)
# output: [1, 2]
        
~~~

##### 7. Product of Array Except Self(238)

- ë¬¸ì œì :
- idea:
- ë°°ìš¸ ì : 

~~~python
# idea: prefix, postfixë¥¼ ì„¤ì •í•œë‹¤.
# Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        # ê³±ì…ˆì„ í•  ê²ƒì´ë¯€ë¡œ ê¸°ë³¸ê°’ì„ 1ë¡œ ì„¤ì •í•œë‹¤
        res = [1] * (len(nums))
        
        prefix = 1
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]
        # print(res)
        postfix = 1
        for i in range(len(nums)-1, -1, -1):
            res[i] *= postfix # prefixì™€ ë‹¬ë¦¬ ê³±ìœ¼ë¡œ ì‹œìž‘í•¨
            postfix *= nums[i]
        # print(res)
        return res
~~~

##### 8. Encode and Decode Strings(271)

- ë¬¸ì œì :
- idea:
- ë°°ìš¸ ì : 

~~~python
# Encode and Decode Strings
# input: ["Hello","World"], output: ["Hello","World"]
class Codec:
    def encode(self, strs: List[str]) -> str:
        """Encodes a list of strings to a single string.
        """
        encoded_str = ''
        # ["Hello","World"] = > 5#Hello5#World
        for s in strs:
            size = len(s)
            encoded_str += str(size) + '#' + s
        return encoded_str
        

    def decode(self, s: str) -> List[str]:
        """Decodes a single string to a list of strings.
        """
        # 5#Hello5#World => ["Hello","World"]
        decoded_str, i = [], 0
        
        while i<len(s):
            j = i
            while s[j] != '#':
                j += 1
            length = int(s[i:j])
            decoded_str.append(s[j+1 : j+1+length])
            i = j + 1 + length
        return decoded_str
~~~

