1. ##### Best Time to Buy and Sell Stock(121)

- ë¬¸ì œ: ì£¼ì‹ìœ¼ë¡œ ê°€ì¥ í° ìˆ˜ìµì„ ë‚´ë ¤ë©´?
- idea: max()ë¡œ ìµœëŒ€ê°’ ê°±ì‹ í•˜ê¸°(Buyë¥¼ ìµœì†Œê°’ì— ê³ ì • í›„ se

~~~python
# [7,1,5,3,6,4] => 5
# idea: Two pointer
# Time O(n) Space O(1)
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy, sell = 0, 1
        max_profit = 0
        
        while sell < len(prices):
            if prices[buy] < prices[sell]:
                max_profit = max(max_profit, (prices[sell] - prices[buy]))
            else:
                buy = sell
            sell += 1
        return max_profit
~~~

2. Longest Substring Without Repeating Characters(3)

- ë¬´ì–¸ê°€ë¥¼ ë„£ê³ , ë¹¼ê³ , ê²€ìƒ‰í•˜ê³ ... ì–´ë–¤ ê±¸ë¡œ í•´ì•¼ í• ê¹Œ. 1) list, 2) dict, 3) set. listëŠ” ì¸ë±ìŠ¤ë¥¼ í™œìš©í•˜ê¸° ë•Œë¬¸ì— ì‚­ì œì‹œ ì¬ì •ë ¬ ë“±ì˜ ë¬¸ì œê°€ ìˆê³ , dictëŠ” ê·¸ëŸ° ê¸°ëŠ¥ì´ ì—†ëŠ” ê²ƒ ê°™ë‹¤. setì„ í™œìš©í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì í•©í•˜ë‹¤. setì„ ë§Œë“œëŠ” ê²ƒì€ O(n). ê²€ìƒ‰ì€ í†µìƒ O(1) ì´ì§€ë§Œ ìµœì•…ì˜ ê²½ìš° O(n) 
- idea: Sliding windowë¥¼ ìœ„í•´ Two pointer ì‚¬ìš©.
- ë°°ìš¸ ì : remove, add, lookup í•  ê²ƒì´ë¼ë©´ set()ì„ í™œìš©í•˜ì

~~~python
# "pwwkew" => 3 // "pwke" is a subsequence and not a substring.
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # "abcabcbb"
        #    l r
        # {c, a, b}
        charSet = set()
        l = 0
        res = 0
        for r in range(len(s)):
            while s[r] in charSet:  # ì´ ë¶€ë¶„ì´ í•µì‹¬ ğŸ³
                charSet.remove(s[l])
                l += 1
            charSet.add(s[r])
            res = max(r-l+1, res)
        return res
~~~

3. Container With Most Water(11)

~~~python

# ë¬¸ì œ: indexì— ë”°ë¥¸ ë†’ì´ê°€ ê°’ìœ¼ë¡œ ì£¼ì–´ì§„ listê°€ ìˆë‹¤. ìµœëŒ€ ë„“ì´ë¥¼ êµ¬í•˜ë¼
# idea:  Sliding windowë¥¼ ìœ„í•´ Two pointer ì‚¬ìš©. ìµœëŒ€ ë„“ì´ë¥¼ êµ¬í•  ê²ƒì´ê¸° ë•Œë¬¸ì— ë†’ì´ê°€ ë‚®ì€ ìª½ì˜ í¬ì¸í„°ë¥¼ ì´ë™í•œë‹¤.
# Time: O(n): Single pass
# Space: O(1)
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # [1,8,6,2,5,4,8,3,7]
        res = 0
        l, r = 0, len(height)-1
        while l < r:
            area = (r - l) * min(height[l], height[r])
            res = max(res, area)
            if height[l] > height[r]:
                r -= 1
            else:
                l += 1
        return res
~~~

4. Longest Repeating Character Replacement(424)

~~~python
# idea: k >= (windowLength - count[mostFreq]). windowLengthê°€ ìµœëŒ€ê°’ìœ¼ë¡œ ê°±ì‹ ë˜ë ¤ë©´ í¬ì¸í„°ì˜ ê°±ì‹ ì€ count[mostFreq]ê°€ ì¦ê°€í•˜ëŠ” ë°©í–¥ì´ì–´ì•¼ íš¨ìœ¨ì ì´ë‹¤.

class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        '''
        "AABABBA", k = 1 => 4
           l
              r
         count = {'A':1, 'B':3}
         res == r - l + 1 = 4// if mostFreq + k > res ==> l += 1
        '''
        count = {}
        res = 0
        # Sliding window
        l = 0
        for r in range(len(s)):
            count[s[r]] = count.get(s[r], 0) + 1
            while (r - l + 1) - max(count.values()) > k: # ì´ ë¶€ë¶„ì´ í•µì‹¬ ğŸŒ¸
                count[s[l]] -= 1
                l += 1
            res = max(res, r - l + 1)    
        return res
~~~

