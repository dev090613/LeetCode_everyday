1. Valid Parentheses(20)

~~~python
# 항상 고민할 것: 어떤 idea로 접근할 것인가. 그리고 그 idea를 채택한 이유는 무엇인가
# 좋은 습관: test case 작성 -> visualization / complexity를 생각해본다.
# 문제: 괄호가 같은 type의 괄호로 닫힘, 올바른 순서로 닫힘, 
# idea: 순서가 있는 문제.. First in한 괄호가 Last out 한다. 여닫는 괄호들이 match 하므로 hash map 사용한다. 닫는 괄호를 발견하면 여는 괄호를 삭제해준다.
# Time O(n) Space O(n)

class Solution:
    def isValid(self, s: str) -> bool:
        '''
        "()[]{}", "{[()]}" "([)]"
        s = "()[]{}" => True
               ^
        stack = [  ] # stack
        closeToOpen = {')':'(', ']':'[', '}':'{'} # hashmap
        '''
        stack = [] # python에서는 list를 stack으로 사용
        closeToOpen = {')':'(', ']':'[', '}':'{'} # It is a Hashmap
        
        #input string에서 하나씩 제거할 것
        for c in s:
            # c가 닫힌 괄호라면?
            if c in closeToOpen: # key를 기준으로 탐색한다.
                # stack이 not empty이며 가장 최근에 삽입된 것이 현재 닫힌 괄호와 짝이라면 제거
                if stack and stack[-1] == closeToOpen[c]:
                    stack.pop()
                else:
                    # print(f"stack is {stack}") # Debug
                    return False
            # c가 닫힌 괄호가 아니라면
            else:
                stack.append(c)
        # print(f"stack is {stack}") # Debug
        # stack이 비어있으면 True 반환 아니면 False 반환
        return True if not stack else False
~~~

