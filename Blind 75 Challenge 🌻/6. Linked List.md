1. Reverse Linked List(206)

- 문제:
- Idea: Two pointer, 
- Learned:

~~~python
# Two pointer solution

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """
              [<-1<-2  3->4->5] 
        curr           ^
        prev        ^
        temp           ^
        
        Time O(n) Memory O(1)
        """
        prev, curr = None, head
        
        while curr:
          	temp = curr.next # 이 부분이 핵심
          	curr.next = prev
            prev = curr
            curr = temp
        return prev        
~~~

~~~python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """
        None head -> head.next -> ... -> None
        임의의 위치(curr)에서 시작
        3 pointer: prev, curr, next_node
        """
        def reverse(curr, prev):
            # Empty list
            if not curr: 
                return prev
            
            next_node = curr.next
            curr.next = prev
            return reverse(next_node, curr)
                
        return reverse(head, None)
~~~

~~~python
# 이해하기 어려운 코드, 일단 건너뛴다.
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """
        1 -> 2 -> 3 -> 4 -> 5 -> None
        5 -> 4 -> 3 -> 2 -> 1 -> None
        Time: O(n) Space: O(n)
        """
        if not head:
            return None
        
        newHead = head # 1
        if head.next:
          	# 2~5까지 reversedList 반환, newHead = 5
            newHead = self.reverseList(head.next)
            # 1 -> 2 <- 3 <- 4 <- 5)
            head.next.next = head
        head.next = None
        return newHead
~~~

2. Merge Two Sorted Lists(21)

- 문제:
- Idea: 
- Learned:

~~~python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        """
        list1: [1,2,4]
                ^
                
        list2: [1,3,4,5,6]
                ^
        Return the head of the merged linked list.
        """
                
        dummy = ListNode() # ListNode{val: 0, next: None}
        tail = dummy
 
        # print(list1) # ListNode{val: 1, next: ListNode{val: 2, next: ListNode{val: 4, next: None}}}
        while list1 and list2:
            if list1.val < list2.val:
                tail.next = list1
                list1 = list1.next
            else:
                tail.next = list2
                list2 = list2.next
            tail = tail.next
        if list1:
            tail.next = list1
        elif list2:
            tail.next = list2
        return dummy.next # Dummy start at None
~~~

3. Reorder List(143)

- 문제:
- Idea: 
- Learned:

~~~python

~~~

4. Linked List Cycle(141)

- 문제:
- Idea: 
- Learned:

~~~python

~~~

