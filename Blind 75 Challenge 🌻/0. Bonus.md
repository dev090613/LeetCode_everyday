---
2023년 5월 8일 시작, 6월 10일까지 내가 원하는 40문제 풀기
---

##### 1. Two sum 2(167) 🪴

- 문제: 오름차순인 list가 있다. 두 item의 합이 target과 같다면, 그 인덱스+1을 반환

- idea: sorted된 상태이므로 양 끝의 Two pointer의 값을 Target과 비교하며 한 칸씩 이동하여 풀 수 있다.
- 배울 것: Two sum1과의 차이는 sorted 되었는지 여부이다. two sum1은 hashmap(value:index)으로 풀었다. sorted 된 경우 two pointer vs target으로 접근하자.
- 다른 풀이: Hashmap, Brute force

~~~python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        """
        전제: 오름차순
           [2,7,11,15], 9
        l:  ^
        r:      ^
        cusSum = 2 + 11 = 9 > target => r-1
        Time: O(n), Space: O(1)
        """
        l, r = 0, len(numbers)-1
        
        while l<r:
            cur_sum = numbers[l] + numbers[r]
            
            if cur_sum > target:
                r -= 1
            elif cur_sum < target:
                l += 1
            else:
                return [l + 1, r + 1]
        return
~~~

2. ##### Remove Duplicates from Sorted Array(26)

- 문제: 오름차순, unique value의 item만으로 당겨서 채워넣어라. 그 후의 값들은 고려하지 않는다. 개수를 반환하라
- idea: Two pointer
- Follow up: Space complexity O(1)

~~~python
# input [0, 1, 2, 2, 3, 3, 4]
# output 5 왜냐하면, [0, 1, 2, 3, 4]
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        """
          [0, 1, 2, 2, 3, 3, 4] => 이렇게 [0, 1, 2, 3, 4]
        l     ^
        r     ^
        """
        l = 1 # index 0 위치는 고려하지 않음
        
        for r in range(1, len(nums)):
            if nums[r] != nums[r-1]: # 이 부분이 핵심 ☘️
                nums[l] = nums[r]
                l += 1
        return l
~~~

3. ##### Maximum Difference Between Increasing Elements(2016)

~~~python
# 주식으로 수익내기와 매우 비슷한 문제 같다.
# 두 요소의 차가 증가분이 아니라면 -1을 반환하라
# idea: Slid window
# 배울 것: 고정 값(작은 값)보다 작은 값이 나오면 그 위치으로 이동한다.
# [3,5,2,10] => 8
# [9,4,3,2] => -1
class Solution:
    def maximumDifference(self, nums: List[int]) -> int:
        l = 0
         
        res = 0
        for r in range(1, len(nums)):
            if nums[l] > nums[r]:
                l = r
            res = max(res, nums[r] - nums[l])
        return res if res != 0 else -1    
~~~

##### 4. Find First Palindromic String in the Array(2018)

~~~python
# idea: Two pointer
# 배울 것: 여러 함수로 쪼개기
# Time: O(n)
# 다른 풀이: slicing
class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for word in words:
            if self.isPalindrome(word):
                return word
        return ""
    
    def isPalindrome(self, word):
        l, r = 0, len(word)-1
        while l<r:
            if word[l] != word[r]:
                return False
            l += 1
            r -= 1
        return True
~~~

~~~python
class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for word in words:
            if word == word[::-1]:
                return word
        return ""
~~~

5. ##### Valid Palindrome II(680)

~~~python
# 문제: Palindrome인지 판단, 하나의 char까지는 지울 수 있다.
# idea: 불일치의 경우 건너뛴 후 다시 함수를 한 번 불러온다. Return으로 바로 끝내기 때문에 몇 번 삭제할 수 있는지에 관해선 고려하지 않았음 flag를 사용하면 삭제 횟수도 조절할 수 있을 것 같음
# 배울 것: return A or B의 사용(logical operator), 함수의 사용법(argument 초기화 조심하기)
# 다른 풀이: Flag를 사용해도 될 것 같은데..., Slicing으로 코드를 작성해도 좋겠다.
class Solution:
    def validPalindrome(self, s: str) -> bool:
        l, r = 0, len(s)-1
        while(l < r):
            if s[l] != s[r]:
                return self.isPalindrome(s, l+1, r) or self.isPalindrome(s, l, r-1)
            l+=1
            r-=1
        return True
    
    def isPalindrome(self, s, l, r):
        # l, r = 0, len(s)-1 # 오답의 원인. 함수를 불러오고나서 다시 초기화 시켰음...
        while l < r:
            if s[l] != s[r]:
                return False
            l+=1
            r-=1
        return True
~~~

