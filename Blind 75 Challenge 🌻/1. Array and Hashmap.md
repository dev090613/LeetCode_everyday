##### Contains Duplicate(217)

- 문제: 
- idea: 
- 배울 점: 

~~~python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        ## 주어진 List[int]에서 동일한 수가 두 번 반복되는지
        ## 방법0: length. Time: O(n), Space: O(n)
        # return len(set(nums)) < len(nums)
        ## 방법1: naive solution O(n^2) O(1) - 각 요소당 루프를 돌며 일치하는 것을 찾아낸다
        ## 방법2: sorting O(nlogn) O(1) - 정렬 후 인접한 두 개의 포인터를 이용하여 서치한다.
        ## 방법3: hashset O(n) O(n) - 약간의 메모리를 더 사용하는 대신 정렬 없이 동일한 value 찾아냄
        hashset = set()
        
        for n in nums:
            if n in hashset:
                return True
            hashset.add(n)
        return False
~~~

##### Valid Anagram(242)

- 문제점:
- idea:
- 배울 점: 

~~~python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        # 문자열 s와 문자열 t가 Anagram인지
        
        ## 방법1: hashset Time: O(s+t) Space: O(s+t)// s+t는 n에 근사한다
        # 두 문자열의 길이가 다르다면 이미 anagram이 아니다
        if len(s) != len(t):
            return False
        
        # s와 t의 hashmap을 만든다.
        count_s, count_t = {}, {}
        
        # 문자열의 인덱스를 따라 진행하여 'a': 1 , 이런 식으로 개수를 셀 것임
        for i in range(len(s)):
            count_s[s[i]] = count_s.get(s[i], 0) + 1
            count_t[t[i]] = count_t.get(t[i], 0) + 1
        for k in count_s:
        #     # if count_s[k] != count_t[k]: 의 문제점?
        #     # keyError가 발생할 수 있다. 아래의 코드가 더욱 개선된 방식이다
        #     # 에러를 반환하지 않고 기본값 0을 반환하여 비교한다.
            if count_s[k] != count_t.get(k, 0):
                return False
        return True
    
        # 방법2: pythonic, Counter(): 방법 2의 기능이 파이썬에 built-in되어 있다. 속도는 더 빠르다.
        # return Counter(s) == Counter(t)
        
        # Follow up: Space: O(1)으로 해결해보기
        ## 방법3: sorted, Time: O(nlogn) Space: O(1)
        # return sorted(s) == sorted(t)        
~~~

##### Two Sum(1)

- 문제점:
- idea:
- 배울 점: 

~~~python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # 방법1: Brute force O(n^2) O(1)
        # 방법2: Hashmap{val: index} O(n) O(n)
        #######################################
        # List를 순회
        # target - value가 hashmap에 없다면
        # hashmap에 val: index 추가
        # 있다면 그 인덱스와 현재 인덱스 반환
        # // 반환할 값이 인덱스이니까 val: index로 설정하는 것 같다
        #######################################
        hashmap = {} # value:inex # 탐색할 것(if in)은 key에 배치, 반환(return)할 것은 value에 배치
        
        # index와 value가 필요한 경우 enumerate를 사용한다. 시작값 바꿀 수 있음
        for i, n in enumerate(nums):
            diff = target - n
            if diff in hashmap:
                return [hashmap[diff], i]
            hashmap[n] = i
        # return # 항상 하나의 sol이 존재하므로 반환값 필요 없음 위에서 다 반환될 것
~~~

##### Group Anagrams(49)

- 문제점:
- idea:
- 배울 점: 

~~~python
# 49. Group Anagrams

# The functionality of both dictionaries and defaultdict are almost same except for the fact that defaultdict never raises a KeyError. It provides a default value for the key that does not exists.

# In python, list can't be key in dictionary. 
# list can be converted to tuple. 
# 따라서, list는 튜플로 변환 후 dict의 key로 사용할 수 있다.
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        # KeyError 대신 empty list 반환
        res = defaultdict(list)
        
        # 동일한 counter를 가진 str들끼리 묶을 것이다.
        # { [counter1] : [str1, str2], 
        #   [counter2] : [str3] }
        for str in strs:
            counter = [0] * 26 # a-z의 반복횟수 저장될 것
            for char in str:
                counter[ord(char) - ord('a')] += 1
            res[tuple(counter)].append(str) # counter 같은 str끼리 모일 것
        return list(res.values())
~~~

~~~python
# 훨씬 축약된 코드, 성능도 더 빠르다
# 위의 counter 를 sorted(str)로 해결
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = defaultdict(list)
        for str in strs:
            res[tuple(sorted(str))].append(str) 
        return list(res.values())
~~~

##### Longest Consecutive Sequence(128)

- 문제점:
- idea:
- 배울 점: 

~~~python
# 128. Longest Consecutive Sequence
# input: [100,4,200,1,3,2] output: 4
# Idea: Consecutive Sequnce의 시작점은 -1의 값을 가지고 있지 않다.
# Time: O(n), Space: O(n)


class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        num_set = set(nums) # 이유: To allow O(1) lookups
        # 반환할 값인 가장 긴 길이
        longest = 0
        
        # nums에서 가장 긴 단편을 찾을 것이다.
        for num in nums: # O(n)
            # 단편의 시작점을 찾는다.
            if (num - 1) not in num_set:
                length = 0 # 1로 두어도 무방
                while (num + length) in num_set:
                    length += 1
                longest = max(length, longest) # scope 주의하기
        return longest
~~~

##### Top K Frequent Elements(347)

- 문제점:
- idea:
- 배울 점: 

~~~python
# idea: frequency를 index로 삼는 array를 만든다. bucket sort
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = {}
        freq = [[] for i in range(len(nums) + 1)] # bucket 만들기. 하나의 숫자만 있는 경우, 한 개도 없는 경우도 고려
        for num in nums:
            count[num] = count.get(num, 0) + 1
        # print(count)
        for n, c in count.items():
            freq[c].append(n)
        # print(freq)
        res = []
        for i in range(len(freq)-1, 0-1, -1):
            for n in freq[i]:
                res.append(n)
                if len(res) == k:
                    return res
        
        
# input: [1,1,1,2,2,3], 2
# count: {1: 3, 2: 2, 3: 1} O(n)
# index, value: [[None], [3], [2], [1], [None], [None], [None]] O(n)
# output: [1, 2]
        
~~~

##### Product of Array Except Self(238)

- 문제점:
- idea:
- 배울 점: 

~~~python
# idea: prefix, postfix를 설정한다.
# Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        # 곱셈을 할 것이므로 기본값을 1로 설정한다
        res = [1] * (len(nums))
        
        prefix = 1
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]
        # print(res)
        postfix = 1
        for i in range(len(nums)-1, -1, -1):
            res[i] *= postfix # prefix와 달리 곱으로 시작함
            postfix *= nums[i]
        # print(res)
        return res
~~~

##### Encode and Decode Strings(271)

- 문제점:
- idea:
- 배울 점: 

~~~python
# Encode and Decode Strings
# input: ["Hello","World"], output: ["Hello","World"]
class Codec:
    def encode(self, strs: List[str]) -> str:
        """Encodes a list of strings to a single string.
        """
        encoded_str = ''
        # ["Hello","World"] = > 5#Hello5#World
        for s in strs:
            size = len(s)
            encoded_str += str(size) + '#' + s
        return encoded_str
        

    def decode(self, s: str) -> List[str]:
        """Decodes a single string to a list of strings.
        """
        # 5#Hello5#World => ["Hello","World"]
        decoded_str, i = [], 0
        
        while i<len(s):
            j = i
            while s[j] != '#':
                j += 1
            length = int(s[i:j])
            decoded_str.append(s[j+1 : j+1+length])
            i = j + 1 + length
        return decoded_str
~~~

